# TWCRM 编码规范 (Coding Standards)

**版本**: 1.0.0
**日期**: 2026-02-24
**适用范围**: 全项目所有模块

---

## 1. 面向对象编程规范 (OOP Standards)

### 1.1 核心原则

本项目采用 **TypeScript 严格模式**，所有业务逻辑必须遵循 OOP 思想：

- **S** — 单一职责 (Single Responsibility)
- **O** — 开闭原则 (Open/Closed)
- **L** — 里氏替换 (Liskov Substitution)
- **I** — 接口隔离 (Interface Segregation)
- **D** — 依赖倒置 (Dependency Inversion)

### 1.2 分层架构

```
┌─────────────────────────────────────────┐
│  UI Layer (React Components)            │  只负责展示，不含业务逻辑
│  └── 调用 Hooks / Server Actions        │
├─────────────────────────────────────────┤
│  Hook Layer (Custom Hooks)              │  组合逻辑，状态管理
│  └── 调用 Service                       │
├─────────────────────────────────────────┤
│  Service Layer (Business Logic)         │  核心业务逻辑，OOP 类
│  └── 调用 Repository                    │
├─────────────────────────────────────────┤
│  Repository Layer (Data Access)         │  数据访问，Prisma 封装
│  └── 调用 Prisma Client                 │
├─────────────────────────────────────────┤
│  Entity / DTO Layer                     │  数据模型，Zod Schema
└─────────────────────────────────────────┘
```

### 1.3 Service 类规范

每个业务模块必须有一个 Service 类，封装所有业务逻辑：

```typescript
// src/features/ordering/services/order.service.ts

import { IOrderRepository } from '../repositories/order.repository'
import { CreateOrderDTO, OrderVO } from '../schemas/order.schema'

// 接口定义（依赖倒置）
export interface IOrderService {
  createOrder(dto: CreateOrderDTO): Promise<OrderVO>
  getOrderById(id: string): Promise<OrderVO | null>
  cancelOrder(id: string, reason: string): Promise<void>
}

// 实现类
export class OrderService implements IOrderService {
  constructor(
    private readonly orderRepo: IOrderRepository,
    private readonly accountService: IAccountService,
    private readonly stockService: IStockService,
    private readonly wsService: IWebSocketService,
  ) {}

  async createOrder(dto: CreateOrderDTO): Promise<OrderVO> {
    // 1. 校验余额
    await this.accountService.checkBalance(dto.tenantId, dto.totalAmount)
    // 2. 校验库存 + MOQ
    await this.stockService.checkAvailability(dto.items)
    // 3. 创建订单（事务）
    const order = await this.orderRepo.createWithTransaction(dto)
    // 4. 扣款
    await this.accountService.deduct(dto.tenantId, dto.totalAmount, order.id)
    // 5. 实时通知总部
    this.wsService.emit('order:new', { orderId: order.id, tenantId: dto.tenantId })
    return order
  }
}
```

### 1.4 Repository 类规范

数据访问层封装 Prisma，隔离 ORM 细节：

```typescript
// src/features/ordering/repositories/order.repository.ts

export interface IOrderRepository {
  findById(id: string): Promise<Order | null>
  findByTenant(tenantId: string, filters: OrderFilters): Promise<PaginatedResult<Order>>
  createWithTransaction(dto: CreateOrderDTO): Promise<Order>
}

export class OrderRepository implements IOrderRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async findByTenant(tenantId: string, filters: OrderFilters) {
    const [items, total] = await Promise.all([
      this.prisma.order.findMany({
        where: { tenantId, ...this.buildWhere(filters) },
        skip: filters.skip,
        take: filters.take,
        orderBy: { createdAt: 'desc' },
        include: { items: true, shipment: true },
      }),
      this.prisma.order.count({
        where: { tenantId, ...this.buildWhere(filters) },
      }),
    ])
    return { items, total, page: filters.page, perPage: filters.perPage }
  }

  private buildWhere(filters: OrderFilters) {
    // 动态构建查询条件
  }
}
```

---

## 2. 全局命名规范

### 2.1 文件命名

| 类型 | 命名规则 | 示例 |
|------|----------|------|
| React 组件 | kebab-case | `order-list.tsx` |
| Server Action | kebab-case | `create-order.ts` |
| Service 类 | kebab-case + `.service` | `order.service.ts` |
| Repository 类 | kebab-case + `.repository` | `order.repository.ts` |
| Hook | camelCase + `use` 前缀 | `use-order.ts` |
| Schema (Zod) | kebab-case + `.schema` | `order.schema.ts` |
| 类型定义 | kebab-case + `.types` | `order.types.ts` |
| 常量 | kebab-case + `.constants` | `order.constants.ts` |
| 工具函数 | kebab-case + `.utils` | `order.utils.ts` |
| WebSocket 事件 | kebab-case + `.events` | `order.events.ts` |

### 2.2 变量/函数命名

| 类型 | 规则 | 示例 |
|------|------|------|
| 变量 | camelCase | `orderList`, `currentUser` |
| 常量 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `ORDER_STATUS` |
| 函数 | camelCase + 动词开头 | `getOrderById`, `createOrder` |
| 类 | PascalCase | `OrderService`, `OrderRepository` |
| 接口 | PascalCase + `I` 前缀 | `IOrderService`, `IOrderRepository` |
| 类型 | PascalCase | `OrderVO`, `CreateOrderDTO` |
| Enum | PascalCase | `OrderStatus`, `PaymentMethod` |
| Hook | camelCase + `use` 前缀 | `useOrder`, `useOrderList` |
| Server Action | camelCase + 动词 | `createOrderAction`, `getOrdersAction` |

### 2.3 DTO / VO 规范

```typescript
// DTO (Data Transfer Object) — 输入数据，用于创建/更新
export const CreateOrderDTO = z.object({
  tenantId: z.string(),
  items: z.array(OrderItemDTO),
  remark: z.string().optional(),
})
export type CreateOrderDTO = z.infer<typeof CreateOrderDTO>

// VO (Value Object) — 输出数据，用于展示
export type OrderVO = {
  id: string
  orderNo: string
  status: OrderStatus
  totalAmount: number
  items: OrderItemVO[]
  shipment: ShipmentVO | null
  createdAt: Date
}
```

---

## 3. 模块目录结构规范

每个 feature 模块必须遵循以下结构：

```
src/features/{module}/
├── components/           # UI 组件（只负责展示）
│   ├── {name}-list.tsx
│   ├── {name}-form.tsx
│   ├── {name}-detail.tsx
│   └── {name}-card.tsx
├── actions/              # Server Actions（"use server"）
│   ├── {name}.actions.ts
│   └── index.ts
├── services/             # 业务逻辑类（OOP）
│   ├── {name}.service.ts
│   └── index.ts
├── repositories/         # 数据访问类（Prisma 封装）
│   ├── {name}.repository.ts
│   └── index.ts
├── hooks/                # 自定义 Hooks
│   ├── use-{name}.ts
│   ├── use-{name}-list.ts
│   └── index.ts
├── schemas/              # Zod Schema + DTO/VO
│   ├── {name}.schema.ts
│   └── index.ts
├── events/               # WebSocket 事件定义
│   └── {name}.events.ts
├── constants/            # 模块常量
│   └── {name}.constants.ts
├── utils/                # 模块工具函数
│   └── {name}.utils.ts
└── types/                # 模块类型定义
    └── {name}.types.ts
```

---

## 4. 组件通信规范

### 4.1 通信方式选择

| 场景 | 方式 | 说明 |
|------|------|------|
| 父 → 子 | Props | 单向数据流 |
| 子 → 父 | Callback Props | `onSubmit`, `onChange` |
| 兄弟组件 | Zustand Store | 共享 UI 状态 |
| 跨模块数据 | Server Actions + Revalidate | 数据变更后 `revalidatePath` |
| 全局实时事件 | WebSocket + Zustand | 订单通知、库存变更等 |
| URL 状态 | Nuqs | 搜索/过滤/分页参数 |

### 4.2 Zustand Store 规范

每个模块一个 Store，命名 `use{Module}Store`：

```typescript
// src/features/ordering/stores/use-ordering-store.ts

interface OrderingState {
  // State
  cart: CartItem[]
  isCartOpen: boolean

  // Actions
  addToCart: (item: CartItem) => void
  removeFromCart: (productId: string) => void
  clearCart: () => void
  toggleCart: () => void
}

export const useOrderingStore = create<OrderingState>((set, get) => ({
  cart: [],
  isCartOpen: false,

  addToCart: (item) => set((state) => ({
    cart: [...state.cart, item]
  })),

  removeFromCart: (productId) => set((state) => ({
    cart: state.cart.filter(i => i.productId !== productId)
  })),

  clearCart: () => set({ cart: [] }),
  toggleCart: () => set((state) => ({ isCartOpen: !state.isCartOpen })),
}))
```

### 4.3 跨模块引用规范

模块之间通过**接口**通信，不直接 import 其他模块的内部实现：

```typescript
// ✅ 正确：通过 Server Action 跨模块调用
import { getCustomerAction } from '@/features/customers/actions'

// ❌ 错误：直接 import 其他模块的 Repository
import { CustomerRepository } from '@/features/customers/repositories'
```

---

## 5. WebSocket 实时系统

### 5.1 技术选型

| 组件 | 技术 | 说明 |
|------|------|------|
| 服务端 | Socket.IO (Server) | 基于 WebSocket，自动降级 |
| 客户端 | Socket.IO (Client) | React Hook 封装 |
| 消息队列 | Redis Pub/Sub | 多实例广播 |
| 认证 | Auth.js Session Token | 连接时校验身份 |

### 5.2 事件命名规范

格式：`{module}:{action}`

| 事件 | 方向 | 说明 |
|------|------|------|
| `order:new` | Server → Client | 新订单通知（总部） |
| `order:status_changed` | Server → Client | 订单状态变更（子公司） |
| `order:shipped` | Server → Client | 发货通知（子公司） |
| `stock:low` | Server → Client | 库存预警（总部） |
| `stock:updated` | Server → Client | 库存变更（相关仓库） |
| `workorder:assigned` | Server → Client | 工单指派通知（员工） |
| `workorder:completed` | Server → Client | 工单完成通知（客户经理） |
| `chat:message` | Bidirectional | 即时消息 |
| `notification:new` | Server → Client | 系统通知 |

### 5.3 事件定义规范

```typescript
// src/lib/ws/events.ts

// 所有 WebSocket 事件的类型定义
export interface ServerToClientEvents {
  'order:new': (data: { orderId: string; tenantId: string; amount: number }) => void
  'order:status_changed': (data: { orderId: string; status: OrderStatus }) => void
  'order:shipped': (data: { orderId: string; trackingNo: string }) => void
  'stock:low': (data: { productId: string; warehouseId: string; quantity: number }) => void
  'stock:updated': (data: { productId: string; warehouseId: string; quantity: number }) => void
  'workorder:assigned': (data: { workOrderId: string; assigneeId: string }) => void
  'workorder:completed': (data: { workOrderId: string }) => void
  'notification:new': (data: NotificationPayload) => void
}

export interface ClientToServerEvents {
  'chat:message': (data: { to: string; content: string }) => void
  'presence:online': () => void
  'presence:offline': () => void
}
```

### 5.4 WebSocket Hook

```typescript
// src/hooks/use-socket.ts

export function useSocket() {
  const socket = useRef<Socket<ServerToClientEvents, ClientToServerEvents> | null>(null)

  useEffect(() => {
    socket.current = io(process.env.NEXT_PUBLIC_WS_URL, {
      auth: { token: getSessionToken() },
      transports: ['websocket'],
    })

    return () => { socket.current?.disconnect() }
  }, [])

  return socket.current
}

// 模块专用 Hook
export function useOrderSocket(onNewOrder?: (data: any) => void) {
  const socket = useSocket()

  useEffect(() => {
    if (!socket) return
    if (onNewOrder) socket.on('order:new', onNewOrder)
    return () => { socket.off('order:new', onNewOrder) }
  }, [socket, onNewOrder])
}
```

### 5.5 WebSocket 服务端

```typescript
// src/lib/ws/server.ts

export class WebSocketServer {
  private io: Server<ClientToServerEvents, ServerToClientEvents>

  constructor(httpServer: HttpServer) {
    this.io = new Server(httpServer, {
      cors: { origin: process.env.CORS_ORIGIN },
      adapter: createAdapter(redisClient, redisSub), // Redis 多实例广播
    })

    this.io.use(this.authMiddleware)
    this.registerHandlers()
  }

  // 认证中间件
  private async authMiddleware(socket: Socket, next: Function) {
    const token = socket.handshake.auth.token
    const session = await verifySession(token)
    if (!session) return next(new Error('Unauthorized'))
    socket.data.user = session.user
    socket.join(`tenant:${session.user.tenantId}`) // 加入租户房间
    next()
  }

  // 发送事件到指定租户
  emitToTenant(tenantId: string, event: string, data: any) {
    this.io.to(`tenant:${tenantId}`).emit(event, data)
  }

  // 发送事件到总部
  emitToPlatform(event: string, data: any) {
    this.io.to('platform').emit(event, data)
  }
}
```

### 5.6 房间 (Room) 设计

| 房间 | 加入条件 | 用途 |
|------|----------|------|
| `platform` | platform_admin 角色 | 总部接收所有事件 |
| `tenant:{tenantId}` | 该租户的所有用户 | 子公司内部事件 |
| `user:{userId}` | 个人 | 个人通知/待办提醒 |
| `workorder:{id}` | 工单相关人员 | 工单实时协作 |

---

## 6. 全局 Hooks 体系

### 6.1 基础 Hooks

| Hook | 用途 | 文件 |
|------|------|------|
| `useAuth` | 当前用户信息/角色/权限 | `src/hooks/use-auth.ts` |
| `useTenant` | 当前租户信息 | `src/hooks/use-tenant.ts` |
| `usePermission` | 权限检查 `can('order:create')` | `src/hooks/use-permission.ts` |
| `useSocket` | WebSocket 连接 | `src/hooks/use-socket.ts` |
| `useLocale` | 当前语言/切换语言 | `src/hooks/use-locale.ts` |
| `useTheme` | 主题切换 | `src/hooks/use-theme.ts` |

### 6.2 数据 Hooks

| Hook | 用途 | 文件 |
|------|------|------|
| `useDataTable` | 通用数据表格（分页/搜索/过滤） | `src/hooks/use-data-table.ts` |
| `useInfiniteList` | 无限滚动列表 | `src/hooks/use-infinite-list.ts` |
| `useUpload` | 文件上传到 MinIO | `src/hooks/use-upload.ts` |
| `useDebounce` | 防抖 | `src/hooks/use-debounce.ts` |
| `useMediaQuery` | 响应式断点 | `src/hooks/use-media-query.ts` |

### 6.3 业务 Hooks（每个模块自带）

```typescript
// src/features/ordering/hooks/use-cart.ts
export function useCart() {
  const { cart, addToCart, removeFromCart, clearCart } = useOrderingStore()
  const totalAmount = useMemo(() => cart.reduce((s, i) => s + i.subtotal, 0), [cart])
  const totalItems = cart.length
  return { cart, totalAmount, totalItems, addToCart, removeFromCart, clearCart }
}

// src/features/ordering/hooks/use-order-list.ts
export function useOrderList(filters: OrderFilters) {
  return useQuery({
    queryKey: ['orders', filters],
    queryFn: () => getOrdersAction(filters),
  })
}

// src/features/ordering/hooks/use-order-realtime.ts
export function useOrderRealtime() {
  const queryClient = useQueryClient()
  useOrderSocket((data) => {
    // 收到新订单事件 → 自动刷新订单列表
    queryClient.invalidateQueries({ queryKey: ['orders'] })
    toast.success(`新訂單 ${data.orderId}`)
  })
}
```

---

## 7. Server Action 规范

### 7.1 统一返回格式

```typescript
// src/lib/action-result.ts

export type ActionResult<T = void> =
  | { success: true; data: T }
  | { success: false; error: string; code?: string }

export function ok<T>(data: T): ActionResult<T> {
  return { success: true, data }
}

export function fail(error: string, code?: string): ActionResult<never> {
  return { success: false, error, code }
}
```

### 7.2 Action 写法

```typescript
// src/features/ordering/actions/create-order.action.ts
'use server'

import { auth } from '@/lib/auth'
import { CreateOrderDTO } from '../schemas/order.schema'
import { OrderService } from '../services/order.service'
import { ok, fail, ActionResult } from '@/lib/action-result'

export async function createOrderAction(
  input: CreateOrderDTO
): Promise<ActionResult<OrderVO>> {
  try {
    const session = await auth()
    if (!session) return fail('未登入', 'UNAUTHORIZED')

    const validated = CreateOrderDTO.parse(input)
    const service = new OrderService(/* DI */)
    const order = await service.createOrder(validated)

    revalidatePath('/ordering/orders')
    return ok(order)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return fail(error.errors[0].message, 'VALIDATION_ERROR')
    }
    return fail(error.message, 'INTERNAL_ERROR')
  }
}
```

---

## 8. 错误处理规范

### 8.1 业务异常类

```typescript
// src/lib/errors.ts

export class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 400,
  ) {
    super(message)
    this.name = 'AppError'
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = '未授權') {
    super(message, 'UNAUTHORIZED', 401)
  }
}

export class ForbiddenError extends AppError {
  constructor(message = '無權限') {
    super(message, 'FORBIDDEN', 403)
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} 不存在`, 'NOT_FOUND', 404)
  }
}

export class InsufficientBalanceError extends AppError {
  constructor() {
    super('餘額不足，請聯繫總部充值', 'INSUFFICIENT_BALANCE', 400)
  }
}

export class InsufficientStockError extends AppError {
  constructor(productName: string, available: number) {
    super(`${productName} 庫存不足，當前庫存 ${available}`, 'INSUFFICIENT_STOCK', 400)
  }
}
```

---

## 9. 依赖注入 (DI) 规范

使用工厂函数创建 Service 实例，统一管理依赖：

```typescript
// src/lib/container.ts

import { PrismaClient } from '@prisma/client'
import { OrderService } from '@/features/ordering/services/order.service'
import { OrderRepository } from '@/features/ordering/repositories/order.repository'
import { AccountService } from '@/features/ordering/services/account.service'
import { WebSocketService } from '@/lib/ws/service'

// 单例 Prisma
const prisma = new PrismaClient()

// 工厂函数
export function createOrderService(): OrderService {
  const orderRepo = new OrderRepository(prisma)
  const accountService = new AccountService(prisma)
  const stockService = new StockService(prisma)
  const wsService = WebSocketService.getInstance()

  return new OrderService(orderRepo, accountService, stockService, wsService)
}
```
